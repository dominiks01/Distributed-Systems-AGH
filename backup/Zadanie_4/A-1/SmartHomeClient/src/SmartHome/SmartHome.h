//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `SmartHome.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __SmartHome_h__
#define __SmartHome_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <Ice/ExceptionHelpers.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 10
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace Interfaces
{

class SmartDevice;
class SmartDevicePrx;
class Detector;
class DetectorPrx;
class LightControl;
class LightControlPrx;

}

namespace Detectors
{

class MoveDetector;
class MoveDetectorPrx;
class SmokeDetector;
class SmokeDetectorPrx;

}

namespace Lights
{

class OutdoorLights;
class OutdoorLightsPrx;
class GeneralLights;
class GeneralLightsPrx;

}

namespace Enums
{

enum class Mode : unsigned char
{
    Active,
    Restricted
};

}

namespace Errors
{

class ActionNotPermitted : public ::Ice::UserExceptionHelper<ActionNotPermitted, ::Ice::UserException>
{
public:

    virtual ~ActionNotPermitted();

    ActionNotPermitted(const ActionNotPermitted&) = default;

    ActionNotPermitted() = default;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

/// \cond INTERNAL
static ActionNotPermitted _iceS_ActionNotPermitted_init;
/// \endcond

class SensitivityLevelOutOfRange : public ::Ice::UserExceptionHelper<SensitivityLevelOutOfRange, ::Ice::UserException>
{
public:

    virtual ~SensitivityLevelOutOfRange();

    SensitivityLevelOutOfRange(const SensitivityLevelOutOfRange&) = default;

    SensitivityLevelOutOfRange() = default;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

class UnknownColor : public ::Ice::UserExceptionHelper<UnknownColor, ::Ice::UserException>
{
public:

    virtual ~UnknownColor();

    UnknownColor(const UnknownColor&) = default;

    UnknownColor() = default;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

class BrightnessLevelOutOfRange : public ::Ice::UserExceptionHelper<BrightnessLevelOutOfRange, ::Ice::UserException>
{
public:

    virtual ~BrightnessLevelOutOfRange();

    BrightnessLevelOutOfRange(const BrightnessLevelOutOfRange&) = default;

    BrightnessLevelOutOfRange() = default;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

}

namespace Interfaces
{

class SmartDevice : public virtual ::Ice::Object
{
public:

    using ProxyType = SmartDevicePrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void changeMode(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_changeMode(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Enums::Mode getMode(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getMode(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void notify(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_notify(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class Detector : public virtual SmartDevice
{
public:

    using ProxyType = DetectorPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void setSensitivityLevel(int level, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setSensitivityLevel(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual int getSensitivityLevel(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getSensitivityLevel(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::string getLocation(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getLocation(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void setLocation(::std::string location, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setLocation(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class LightControl : public virtual SmartDevice
{
public:

    using ProxyType = LightControlPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void turnOn(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_turnOn(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void turnOff(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_turnOff(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool isOn(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_isOn(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace Detectors
{

class MoveDetector : public virtual ::Interfaces::SmartDevice,
                     public virtual ::Interfaces::Detector
{
public:

    using ProxyType = MoveDetectorPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual bool motionDetected(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_motionDetected(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class SmokeDetector : public virtual ::Interfaces::SmartDevice,
                      public virtual ::Interfaces::Detector
{
public:

    using ProxyType = SmokeDetectorPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual int getSmokeDensity(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getSmokeDensity(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool isSave(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_isSave(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace Lights
{

class OutdoorLights : public virtual ::Interfaces::LightControl
{
public:

    using ProxyType = OutdoorLightsPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void adjustBrightness(int level, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_adjustBrightness(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual int getBrightnessLevel(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getBrightnessLevel(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class GeneralLights : public virtual ::Interfaces::LightControl
{
public:

    using ProxyType = GeneralLightsPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void changeColor(::std::string color, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_changeColor(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::string getColor(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getColor(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace Interfaces
{

class SmartDevicePrx : public virtual ::Ice::Proxy<SmartDevicePrx, ::Ice::ObjectPrx>
{
public:

    void changeMode(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &SmartDevicePrx::_iceI_changeMode, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto changeModeAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &SmartDevicePrx::_iceI_changeMode, context);
    }

    ::std::function<void()>
    changeModeAsync(::std::function<void()> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Interfaces::SmartDevicePrx::_iceI_changeMode, context);
    }

    /// \cond INTERNAL
    void _iceI_changeMode(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    ::Enums::Mode getMode(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::Enums::Mode>(true, this, &SmartDevicePrx::_iceI_getMode, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getModeAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::Enums::Mode>>().get_future())
    {
        return _makePromiseOutgoing<::Enums::Mode, P>(false, this, &SmartDevicePrx::_iceI_getMode, context);
    }

    ::std::function<void()>
    getModeAsync(::std::function<void(::Enums::Mode)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::Enums::Mode>(std::move(response), std::move(ex), std::move(sent), this, &Interfaces::SmartDevicePrx::_iceI_getMode, context);
    }

    /// \cond INTERNAL
    void _iceI_getMode(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Enums::Mode>>&, const ::Ice::Context&);
    /// \endcond

    void notify(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &SmartDevicePrx::_iceI_notify, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto notifyAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &SmartDevicePrx::_iceI_notify, context);
    }

    ::std::function<void()>
    notifyAsync(::std::function<void()> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Interfaces::SmartDevicePrx::_iceI_notify, context);
    }

    /// \cond INTERNAL
    void _iceI_notify(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    SmartDevicePrx() = default;
    friend ::std::shared_ptr<SmartDevicePrx> IceInternal::createProxy<SmartDevicePrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class DetectorPrx : public virtual ::Ice::Proxy<DetectorPrx, SmartDevicePrx>
{
public:

    void setSensitivityLevel(int level, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &DetectorPrx::_iceI_setSensitivityLevel, level, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setSensitivityLevelAsync(int level, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &DetectorPrx::_iceI_setSensitivityLevel, level, context);
    }

    ::std::function<void()>
    setSensitivityLevelAsync(int level,
                             ::std::function<void()> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Interfaces::DetectorPrx::_iceI_setSensitivityLevel, level, context);
    }

    /// \cond INTERNAL
    void _iceI_setSensitivityLevel(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, const ::Ice::Context&);
    /// \endcond

    int getSensitivityLevel(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<int>(true, this, &DetectorPrx::_iceI_getSensitivityLevel, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getSensitivityLevelAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<int>>().get_future())
    {
        return _makePromiseOutgoing<int, P>(false, this, &DetectorPrx::_iceI_getSensitivityLevel, context);
    }

    ::std::function<void()>
    getSensitivityLevelAsync(::std::function<void(int)> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<int>(std::move(response), std::move(ex), std::move(sent), this, &Interfaces::DetectorPrx::_iceI_getSensitivityLevel, context);
    }

    /// \cond INTERNAL
    void _iceI_getSensitivityLevel(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>&, const ::Ice::Context&);
    /// \endcond

    ::std::string getLocation(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::string>(true, this, &DetectorPrx::_iceI_getLocation, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getLocationAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::string>>().get_future())
    {
        return _makePromiseOutgoing<::std::string, P>(false, this, &DetectorPrx::_iceI_getLocation, context);
    }

    ::std::function<void()>
    getLocationAsync(::std::function<void(::std::string)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::string>(std::move(response), std::move(ex), std::move(sent), this, &Interfaces::DetectorPrx::_iceI_getLocation, context);
    }

    /// \cond INTERNAL
    void _iceI_getLocation(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>&, const ::Ice::Context&);
    /// \endcond

    void setLocation(const ::std::string& location, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &DetectorPrx::_iceI_setLocation, location, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setLocationAsync(const ::std::string& location, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &DetectorPrx::_iceI_setLocation, location, context);
    }

    ::std::function<void()>
    setLocationAsync(const ::std::string& location,
                     ::std::function<void()> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Interfaces::DetectorPrx::_iceI_setLocation, location, context);
    }

    /// \cond INTERNAL
    void _iceI_setLocation(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    DetectorPrx() = default;
    friend ::std::shared_ptr<DetectorPrx> IceInternal::createProxy<DetectorPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class LightControlPrx : public virtual ::Ice::Proxy<LightControlPrx, SmartDevicePrx>
{
public:

    void turnOn(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &LightControlPrx::_iceI_turnOn, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto turnOnAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &LightControlPrx::_iceI_turnOn, context);
    }

    ::std::function<void()>
    turnOnAsync(::std::function<void()> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Interfaces::LightControlPrx::_iceI_turnOn, context);
    }

    /// \cond INTERNAL
    void _iceI_turnOn(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void turnOff(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &LightControlPrx::_iceI_turnOff, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto turnOffAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &LightControlPrx::_iceI_turnOff, context);
    }

    ::std::function<void()>
    turnOffAsync(::std::function<void()> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Interfaces::LightControlPrx::_iceI_turnOff, context);
    }

    /// \cond INTERNAL
    void _iceI_turnOff(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    bool isOn(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &LightControlPrx::_iceI_isOn, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto isOnAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &LightControlPrx::_iceI_isOn, context);
    }

    ::std::function<void()>
    isOnAsync(::std::function<void(bool)> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &Interfaces::LightControlPrx::_iceI_isOn, context);
    }

    /// \cond INTERNAL
    void _iceI_isOn(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    LightControlPrx() = default;
    friend ::std::shared_ptr<LightControlPrx> IceInternal::createProxy<LightControlPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

namespace Detectors
{

class MoveDetectorPrx : public virtual ::Ice::Proxy<MoveDetectorPrx, ::Interfaces::SmartDevicePrx, ::Interfaces::DetectorPrx>
{
public:

    bool motionDetected(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &MoveDetectorPrx::_iceI_motionDetected, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto motionDetectedAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &MoveDetectorPrx::_iceI_motionDetected, context);
    }

    ::std::function<void()>
    motionDetectedAsync(::std::function<void(bool)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &Detectors::MoveDetectorPrx::_iceI_motionDetected, context);
    }

    /// \cond INTERNAL
    void _iceI_motionDetected(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    MoveDetectorPrx() = default;
    friend ::std::shared_ptr<MoveDetectorPrx> IceInternal::createProxy<MoveDetectorPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class SmokeDetectorPrx : public virtual ::Ice::Proxy<SmokeDetectorPrx, ::Interfaces::SmartDevicePrx, ::Interfaces::DetectorPrx>
{
public:

    int getSmokeDensity(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<int>(true, this, &SmokeDetectorPrx::_iceI_getSmokeDensity, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getSmokeDensityAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<int>>().get_future())
    {
        return _makePromiseOutgoing<int, P>(false, this, &SmokeDetectorPrx::_iceI_getSmokeDensity, context);
    }

    ::std::function<void()>
    getSmokeDensityAsync(::std::function<void(int)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<int>(std::move(response), std::move(ex), std::move(sent), this, &Detectors::SmokeDetectorPrx::_iceI_getSmokeDensity, context);
    }

    /// \cond INTERNAL
    void _iceI_getSmokeDensity(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>&, const ::Ice::Context&);
    /// \endcond

    bool isSave(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &SmokeDetectorPrx::_iceI_isSave, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto isSaveAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &SmokeDetectorPrx::_iceI_isSave, context);
    }

    ::std::function<void()>
    isSaveAsync(::std::function<void(bool)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &Detectors::SmokeDetectorPrx::_iceI_isSave, context);
    }

    /// \cond INTERNAL
    void _iceI_isSave(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    SmokeDetectorPrx() = default;
    friend ::std::shared_ptr<SmokeDetectorPrx> IceInternal::createProxy<SmokeDetectorPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

namespace Lights
{

class OutdoorLightsPrx : public virtual ::Ice::Proxy<OutdoorLightsPrx, ::Interfaces::LightControlPrx>
{
public:

    void adjustBrightness(int level, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &OutdoorLightsPrx::_iceI_adjustBrightness, level, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto adjustBrightnessAsync(int level, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &OutdoorLightsPrx::_iceI_adjustBrightness, level, context);
    }

    ::std::function<void()>
    adjustBrightnessAsync(int level,
                          ::std::function<void()> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Lights::OutdoorLightsPrx::_iceI_adjustBrightness, level, context);
    }

    /// \cond INTERNAL
    void _iceI_adjustBrightness(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, const ::Ice::Context&);
    /// \endcond

    int getBrightnessLevel(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<int>(true, this, &OutdoorLightsPrx::_iceI_getBrightnessLevel, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getBrightnessLevelAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<int>>().get_future())
    {
        return _makePromiseOutgoing<int, P>(false, this, &OutdoorLightsPrx::_iceI_getBrightnessLevel, context);
    }

    ::std::function<void()>
    getBrightnessLevelAsync(::std::function<void(int)> response,
                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                            ::std::function<void(bool)> sent = nullptr,
                            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<int>(std::move(response), std::move(ex), std::move(sent), this, &Lights::OutdoorLightsPrx::_iceI_getBrightnessLevel, context);
    }

    /// \cond INTERNAL
    void _iceI_getBrightnessLevel(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    OutdoorLightsPrx() = default;
    friend ::std::shared_ptr<OutdoorLightsPrx> IceInternal::createProxy<OutdoorLightsPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class GeneralLightsPrx : public virtual ::Ice::Proxy<GeneralLightsPrx, ::Interfaces::LightControlPrx>
{
public:

    void changeColor(const ::std::string& color, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &GeneralLightsPrx::_iceI_changeColor, color, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto changeColorAsync(const ::std::string& color, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &GeneralLightsPrx::_iceI_changeColor, color, context);
    }

    ::std::function<void()>
    changeColorAsync(const ::std::string& color,
                     ::std::function<void()> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Lights::GeneralLightsPrx::_iceI_changeColor, color, context);
    }

    /// \cond INTERNAL
    void _iceI_changeColor(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ::std::string getColor(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::string>(true, this, &GeneralLightsPrx::_iceI_getColor, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getColorAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::string>>().get_future())
    {
        return _makePromiseOutgoing<::std::string, P>(false, this, &GeneralLightsPrx::_iceI_getColor, context);
    }

    ::std::function<void()>
    getColorAsync(::std::function<void(::std::string)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::string>(std::move(response), std::move(ex), std::move(sent), this, &Lights::GeneralLightsPrx::_iceI_getColor, context);
    }

    /// \cond INTERNAL
    void _iceI_getColor(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    GeneralLightsPrx() = default;
    friend ::std::shared_ptr<GeneralLightsPrx> IceInternal::createProxy<GeneralLightsPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::Enums::Mode>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 1;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

}
/// \endcond

/// \cond STREAM
namespace Ice
{

}
/// \endcond

/// \cond STREAM
namespace Ice
{

}
/// \endcond

/// \cond STREAM
namespace Ice
{

}
/// \endcond

/// \cond STREAM
namespace Ice
{

}
/// \endcond

/// \cond INTERNAL
namespace Interfaces
{

using SmartDevicePtr = ::std::shared_ptr<SmartDevice>;
using SmartDevicePrxPtr = ::std::shared_ptr<SmartDevicePrx>;

using DetectorPtr = ::std::shared_ptr<Detector>;
using DetectorPrxPtr = ::std::shared_ptr<DetectorPrx>;

using LightControlPtr = ::std::shared_ptr<LightControl>;
using LightControlPrxPtr = ::std::shared_ptr<LightControlPrx>;

}
/// \endcond

/// \cond INTERNAL
namespace Detectors
{

using MoveDetectorPtr = ::std::shared_ptr<MoveDetector>;
using MoveDetectorPrxPtr = ::std::shared_ptr<MoveDetectorPrx>;

using SmokeDetectorPtr = ::std::shared_ptr<SmokeDetector>;
using SmokeDetectorPrxPtr = ::std::shared_ptr<SmokeDetectorPrx>;

}
/// \endcond

/// \cond INTERNAL
namespace Lights
{

using OutdoorLightsPtr = ::std::shared_ptr<OutdoorLights>;
using OutdoorLightsPrxPtr = ::std::shared_ptr<OutdoorLightsPrx>;

using GeneralLightsPtr = ::std::shared_ptr<GeneralLights>;
using GeneralLightsPrxPtr = ::std::shared_ptr<GeneralLightsPrx>;

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace Interfaces
{

class SmartDevice;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< SmartDevice>&);
::IceProxy::Ice::Object* upCast(SmartDevice*);
/// \endcond

class Detector;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Detector>&);
::IceProxy::Ice::Object* upCast(Detector*);
/// \endcond

class LightControl;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< LightControl>&);
::IceProxy::Ice::Object* upCast(LightControl*);
/// \endcond

}

namespace Detectors
{

class MoveDetector;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< MoveDetector>&);
::IceProxy::Ice::Object* upCast(MoveDetector*);
/// \endcond

class SmokeDetector;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< SmokeDetector>&);
::IceProxy::Ice::Object* upCast(SmokeDetector*);
/// \endcond

}

namespace Lights
{

class OutdoorLights;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< OutdoorLights>&);
::IceProxy::Ice::Object* upCast(OutdoorLights*);
/// \endcond

class GeneralLights;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< GeneralLights>&);
::IceProxy::Ice::Object* upCast(GeneralLights*);
/// \endcond

}

}

namespace Interfaces
{

class SmartDevice;
/// \cond INTERNAL
::Ice::Object* upCast(SmartDevice*);
/// \endcond
typedef ::IceInternal::Handle< SmartDevice> SmartDevicePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Interfaces::SmartDevice> SmartDevicePrx;
typedef SmartDevicePrx SmartDevicePrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(SmartDevicePtr&, const ::Ice::ObjectPtr&);
/// \endcond

class Detector;
/// \cond INTERNAL
::Ice::Object* upCast(Detector*);
/// \endcond
typedef ::IceInternal::Handle< Detector> DetectorPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Interfaces::Detector> DetectorPrx;
typedef DetectorPrx DetectorPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(DetectorPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class LightControl;
/// \cond INTERNAL
::Ice::Object* upCast(LightControl*);
/// \endcond
typedef ::IceInternal::Handle< LightControl> LightControlPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Interfaces::LightControl> LightControlPrx;
typedef LightControlPrx LightControlPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(LightControlPtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

namespace Detectors
{

class MoveDetector;
/// \cond INTERNAL
::Ice::Object* upCast(MoveDetector*);
/// \endcond
typedef ::IceInternal::Handle< MoveDetector> MoveDetectorPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Detectors::MoveDetector> MoveDetectorPrx;
typedef MoveDetectorPrx MoveDetectorPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(MoveDetectorPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class SmokeDetector;
/// \cond INTERNAL
::Ice::Object* upCast(SmokeDetector*);
/// \endcond
typedef ::IceInternal::Handle< SmokeDetector> SmokeDetectorPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Detectors::SmokeDetector> SmokeDetectorPrx;
typedef SmokeDetectorPrx SmokeDetectorPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(SmokeDetectorPtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

namespace Lights
{

class OutdoorLights;
/// \cond INTERNAL
::Ice::Object* upCast(OutdoorLights*);
/// \endcond
typedef ::IceInternal::Handle< OutdoorLights> OutdoorLightsPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Lights::OutdoorLights> OutdoorLightsPrx;
typedef OutdoorLightsPrx OutdoorLightsPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(OutdoorLightsPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class GeneralLights;
/// \cond INTERNAL
::Ice::Object* upCast(GeneralLights*);
/// \endcond
typedef ::IceInternal::Handle< GeneralLights> GeneralLightsPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Lights::GeneralLights> GeneralLightsPrx;
typedef GeneralLightsPrx GeneralLightsPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(GeneralLightsPtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

namespace Enums
{

enum Mode
{
    Active,
    Restricted
};

}

namespace Errors
{

class ActionNotPermitted : public ::Ice::UserException
{
public:

    ActionNotPermitted() {}

#ifdef ICE_CPP11_COMPILER
    ActionNotPermitted(const ActionNotPermitted&) = default;
    virtual ~ActionNotPermitted();
#else
    virtual ~ActionNotPermitted() throw();
#endif

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual ActionNotPermitted* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
static ActionNotPermitted _iceS_ActionNotPermitted_init;
/// \endcond

class SensitivityLevelOutOfRange : public ::Ice::UserException
{
public:

    SensitivityLevelOutOfRange() {}

#ifdef ICE_CPP11_COMPILER
    SensitivityLevelOutOfRange(const SensitivityLevelOutOfRange&) = default;
    virtual ~SensitivityLevelOutOfRange();
#else
    virtual ~SensitivityLevelOutOfRange() throw();
#endif

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual SensitivityLevelOutOfRange* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

class UnknownColor : public ::Ice::UserException
{
public:

    UnknownColor() {}

#ifdef ICE_CPP11_COMPILER
    UnknownColor(const UnknownColor&) = default;
    virtual ~UnknownColor();
#else
    virtual ~UnknownColor() throw();
#endif

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual UnknownColor* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

class BrightnessLevelOutOfRange : public ::Ice::UserException
{
public:

    BrightnessLevelOutOfRange() {}

#ifdef ICE_CPP11_COMPILER
    BrightnessLevelOutOfRange(const BrightnessLevelOutOfRange&) = default;
    virtual ~BrightnessLevelOutOfRange();
#else
    virtual ~BrightnessLevelOutOfRange() throw();
#endif

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual BrightnessLevelOutOfRange* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

}

namespace Interfaces
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Interfaces::SmartDevice::begin_changeMode.
 * Create a wrapper instance by calling ::Interfaces::newCallback_SmartDevice_changeMode.
 */
class Callback_SmartDevice_changeMode_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_SmartDevice_changeMode_Base> Callback_SmartDevice_changeModePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Interfaces::SmartDevice::begin_getMode.
 * Create a wrapper instance by calling ::Interfaces::newCallback_SmartDevice_getMode.
 */
class Callback_SmartDevice_getMode_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_SmartDevice_getMode_Base> Callback_SmartDevice_getModePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Interfaces::SmartDevice::begin_notify.
 * Create a wrapper instance by calling ::Interfaces::newCallback_SmartDevice_notify.
 */
class Callback_SmartDevice_notify_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_SmartDevice_notify_Base> Callback_SmartDevice_notifyPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Interfaces::Detector::begin_setSensitivityLevel.
 * Create a wrapper instance by calling ::Interfaces::newCallback_Detector_setSensitivityLevel.
 */
class Callback_Detector_setSensitivityLevel_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Detector_setSensitivityLevel_Base> Callback_Detector_setSensitivityLevelPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Interfaces::Detector::begin_getSensitivityLevel.
 * Create a wrapper instance by calling ::Interfaces::newCallback_Detector_getSensitivityLevel.
 */
class Callback_Detector_getSensitivityLevel_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Detector_getSensitivityLevel_Base> Callback_Detector_getSensitivityLevelPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Interfaces::Detector::begin_getLocation.
 * Create a wrapper instance by calling ::Interfaces::newCallback_Detector_getLocation.
 */
class Callback_Detector_getLocation_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Detector_getLocation_Base> Callback_Detector_getLocationPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Interfaces::Detector::begin_setLocation.
 * Create a wrapper instance by calling ::Interfaces::newCallback_Detector_setLocation.
 */
class Callback_Detector_setLocation_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Detector_setLocation_Base> Callback_Detector_setLocationPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Interfaces::LightControl::begin_turnOn.
 * Create a wrapper instance by calling ::Interfaces::newCallback_LightControl_turnOn.
 */
class Callback_LightControl_turnOn_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LightControl_turnOn_Base> Callback_LightControl_turnOnPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Interfaces::LightControl::begin_turnOff.
 * Create a wrapper instance by calling ::Interfaces::newCallback_LightControl_turnOff.
 */
class Callback_LightControl_turnOff_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LightControl_turnOff_Base> Callback_LightControl_turnOffPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Interfaces::LightControl::begin_isOn.
 * Create a wrapper instance by calling ::Interfaces::newCallback_LightControl_isOn.
 */
class Callback_LightControl_isOn_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LightControl_isOn_Base> Callback_LightControl_isOnPtr;

}

namespace Detectors
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Detectors::MoveDetector::begin_motionDetected.
 * Create a wrapper instance by calling ::Detectors::newCallback_MoveDetector_motionDetected.
 */
class Callback_MoveDetector_motionDetected_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MoveDetector_motionDetected_Base> Callback_MoveDetector_motionDetectedPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Detectors::SmokeDetector::begin_getSmokeDensity.
 * Create a wrapper instance by calling ::Detectors::newCallback_SmokeDetector_getSmokeDensity.
 */
class Callback_SmokeDetector_getSmokeDensity_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_SmokeDetector_getSmokeDensity_Base> Callback_SmokeDetector_getSmokeDensityPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Detectors::SmokeDetector::begin_isSave.
 * Create a wrapper instance by calling ::Detectors::newCallback_SmokeDetector_isSave.
 */
class Callback_SmokeDetector_isSave_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_SmokeDetector_isSave_Base> Callback_SmokeDetector_isSavePtr;

}

namespace Lights
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Lights::OutdoorLights::begin_adjustBrightness.
 * Create a wrapper instance by calling ::Lights::newCallback_OutdoorLights_adjustBrightness.
 */
class Callback_OutdoorLights_adjustBrightness_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_OutdoorLights_adjustBrightness_Base> Callback_OutdoorLights_adjustBrightnessPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Lights::OutdoorLights::begin_getBrightnessLevel.
 * Create a wrapper instance by calling ::Lights::newCallback_OutdoorLights_getBrightnessLevel.
 */
class Callback_OutdoorLights_getBrightnessLevel_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_OutdoorLights_getBrightnessLevel_Base> Callback_OutdoorLights_getBrightnessLevelPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Lights::GeneralLights::begin_changeColor.
 * Create a wrapper instance by calling ::Lights::newCallback_GeneralLights_changeColor.
 */
class Callback_GeneralLights_changeColor_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GeneralLights_changeColor_Base> Callback_GeneralLights_changeColorPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Lights::GeneralLights::begin_getColor.
 * Create a wrapper instance by calling ::Lights::newCallback_GeneralLights_getColor.
 */
class Callback_GeneralLights_getColor_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GeneralLights_getColor_Base> Callback_GeneralLights_getColorPtr;

}

namespace IceProxy
{

namespace Interfaces
{

class SmartDevice : public virtual ::Ice::Proxy<SmartDevice, ::IceProxy::Ice::Object>
{
public:

    void changeMode(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_changeMode(_iceI_begin_changeMode(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_changeMode(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_changeMode(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_changeMode(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_changeMode(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_changeMode(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_changeMode(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_changeMode(const ::Interfaces::Callback_SmartDevice_changeModePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_changeMode(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_changeMode(const ::Ice::Context& context, const ::Interfaces::Callback_SmartDevice_changeModePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_changeMode(context, cb, cookie);
    }

    void end_changeMode(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_changeMode(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Enums::Mode getMode(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getMode(_iceI_begin_getMode(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getMode(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getMode(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getMode(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getMode(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getMode(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getMode(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getMode(const ::Interfaces::Callback_SmartDevice_getModePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getMode(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getMode(const ::Ice::Context& context, const ::Interfaces::Callback_SmartDevice_getModePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getMode(context, cb, cookie);
    }

    ::Enums::Mode end_getMode(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getMode(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void notify(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_notify(_iceI_begin_notify(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_notify(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_notify(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_notify(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_notify(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_notify(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_notify(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_notify(const ::Interfaces::Callback_SmartDevice_notifyPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_notify(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_notify(const ::Ice::Context& context, const ::Interfaces::Callback_SmartDevice_notifyPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_notify(context, cb, cookie);
    }

    void end_notify(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_notify(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class Detector : public virtual ::Ice::Proxy<Detector, ::IceProxy::Interfaces::SmartDevice>
{
public:

    void setSensitivityLevel(::Ice::Int level, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_setSensitivityLevel(_iceI_begin_setSensitivityLevel(level, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setSensitivityLevel(::Ice::Int level, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setSensitivityLevel(level, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setSensitivityLevel(::Ice::Int level, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setSensitivityLevel(level, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setSensitivityLevel(::Ice::Int level, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setSensitivityLevel(level, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setSensitivityLevel(::Ice::Int level, const ::Interfaces::Callback_Detector_setSensitivityLevelPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setSensitivityLevel(level, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setSensitivityLevel(::Ice::Int level, const ::Ice::Context& context, const ::Interfaces::Callback_Detector_setSensitivityLevelPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setSensitivityLevel(level, context, cb, cookie);
    }

    void end_setSensitivityLevel(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setSensitivityLevel(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Ice::Int getSensitivityLevel(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getSensitivityLevel(_iceI_begin_getSensitivityLevel(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getSensitivityLevel(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getSensitivityLevel(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getSensitivityLevel(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getSensitivityLevel(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getSensitivityLevel(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getSensitivityLevel(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getSensitivityLevel(const ::Interfaces::Callback_Detector_getSensitivityLevelPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getSensitivityLevel(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getSensitivityLevel(const ::Ice::Context& context, const ::Interfaces::Callback_Detector_getSensitivityLevelPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getSensitivityLevel(context, cb, cookie);
    }

    ::Ice::Int end_getSensitivityLevel(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getSensitivityLevel(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::std::string getLocation(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getLocation(_iceI_begin_getLocation(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getLocation(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getLocation(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getLocation(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getLocation(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getLocation(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getLocation(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getLocation(const ::Interfaces::Callback_Detector_getLocationPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getLocation(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getLocation(const ::Ice::Context& context, const ::Interfaces::Callback_Detector_getLocationPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getLocation(context, cb, cookie);
    }

    ::std::string end_getLocation(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getLocation(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void setLocation(const ::std::string& location, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_setLocation(_iceI_begin_setLocation(location, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setLocation(const ::std::string& location, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setLocation(location, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setLocation(const ::std::string& location, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setLocation(location, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setLocation(const ::std::string& location, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setLocation(location, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setLocation(const ::std::string& location, const ::Interfaces::Callback_Detector_setLocationPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setLocation(location, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setLocation(const ::std::string& location, const ::Ice::Context& context, const ::Interfaces::Callback_Detector_setLocationPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setLocation(location, context, cb, cookie);
    }

    void end_setLocation(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setLocation(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class LightControl : public virtual ::Ice::Proxy<LightControl, ::IceProxy::Interfaces::SmartDevice>
{
public:

    void turnOn(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_turnOn(_iceI_begin_turnOn(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_turnOn(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_turnOn(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_turnOn(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_turnOn(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_turnOn(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_turnOn(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_turnOn(const ::Interfaces::Callback_LightControl_turnOnPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_turnOn(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_turnOn(const ::Ice::Context& context, const ::Interfaces::Callback_LightControl_turnOnPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_turnOn(context, cb, cookie);
    }

    void end_turnOn(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_turnOn(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void turnOff(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_turnOff(_iceI_begin_turnOff(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_turnOff(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_turnOff(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_turnOff(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_turnOff(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_turnOff(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_turnOff(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_turnOff(const ::Interfaces::Callback_LightControl_turnOffPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_turnOff(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_turnOff(const ::Ice::Context& context, const ::Interfaces::Callback_LightControl_turnOffPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_turnOff(context, cb, cookie);
    }

    void end_turnOff(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_turnOff(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool isOn(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_isOn(_iceI_begin_isOn(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_isOn(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_isOn(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_isOn(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_isOn(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_isOn(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_isOn(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_isOn(const ::Interfaces::Callback_LightControl_isOnPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_isOn(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_isOn(const ::Ice::Context& context, const ::Interfaces::Callback_LightControl_isOnPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_isOn(context, cb, cookie);
    }

    bool end_isOn(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_isOn(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

namespace Detectors
{

/// \cond INTERNAL
class _MoveDetectorBase : public virtual ::IceProxy::Interfaces::SmartDevice, 
                          public virtual ::IceProxy::Interfaces::Detector
{
public:

    virtual ~_MoveDetectorBase();

protected:

    virtual Object* _newInstance() const = 0;
};
/// \endcond

class MoveDetector : public virtual ::Ice::Proxy<MoveDetector, _MoveDetectorBase>
{
public:

    bool motionDetected(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_motionDetected(_iceI_begin_motionDetected(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_motionDetected(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_motionDetected(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_motionDetected(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_motionDetected(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_motionDetected(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_motionDetected(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_motionDetected(const ::Detectors::Callback_MoveDetector_motionDetectedPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_motionDetected(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_motionDetected(const ::Ice::Context& context, const ::Detectors::Callback_MoveDetector_motionDetectedPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_motionDetected(context, cb, cookie);
    }

    bool end_motionDetected(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_motionDetected(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

/// \cond INTERNAL
class _SmokeDetectorBase : public virtual ::IceProxy::Interfaces::SmartDevice, 
                           public virtual ::IceProxy::Interfaces::Detector
{
public:

    virtual ~_SmokeDetectorBase();

protected:

    virtual Object* _newInstance() const = 0;
};
/// \endcond

class SmokeDetector : public virtual ::Ice::Proxy<SmokeDetector, _SmokeDetectorBase>
{
public:

    ::Ice::Int getSmokeDensity(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getSmokeDensity(_iceI_begin_getSmokeDensity(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getSmokeDensity(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getSmokeDensity(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getSmokeDensity(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getSmokeDensity(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getSmokeDensity(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getSmokeDensity(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getSmokeDensity(const ::Detectors::Callback_SmokeDetector_getSmokeDensityPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getSmokeDensity(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getSmokeDensity(const ::Ice::Context& context, const ::Detectors::Callback_SmokeDetector_getSmokeDensityPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getSmokeDensity(context, cb, cookie);
    }

    ::Ice::Int end_getSmokeDensity(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getSmokeDensity(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool isSave(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_isSave(_iceI_begin_isSave(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_isSave(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_isSave(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_isSave(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_isSave(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_isSave(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_isSave(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_isSave(const ::Detectors::Callback_SmokeDetector_isSavePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_isSave(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_isSave(const ::Ice::Context& context, const ::Detectors::Callback_SmokeDetector_isSavePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_isSave(context, cb, cookie);
    }

    bool end_isSave(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_isSave(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

namespace Lights
{

class OutdoorLights : public virtual ::Ice::Proxy<OutdoorLights, ::IceProxy::Interfaces::LightControl>
{
public:

    void adjustBrightness(::Ice::Int level, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_adjustBrightness(_iceI_begin_adjustBrightness(level, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_adjustBrightness(::Ice::Int level, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_adjustBrightness(level, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_adjustBrightness(::Ice::Int level, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_adjustBrightness(level, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_adjustBrightness(::Ice::Int level, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_adjustBrightness(level, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_adjustBrightness(::Ice::Int level, const ::Lights::Callback_OutdoorLights_adjustBrightnessPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_adjustBrightness(level, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_adjustBrightness(::Ice::Int level, const ::Ice::Context& context, const ::Lights::Callback_OutdoorLights_adjustBrightnessPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_adjustBrightness(level, context, cb, cookie);
    }

    void end_adjustBrightness(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_adjustBrightness(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Ice::Int getBrightnessLevel(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getBrightnessLevel(_iceI_begin_getBrightnessLevel(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getBrightnessLevel(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getBrightnessLevel(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getBrightnessLevel(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getBrightnessLevel(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getBrightnessLevel(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getBrightnessLevel(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getBrightnessLevel(const ::Lights::Callback_OutdoorLights_getBrightnessLevelPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getBrightnessLevel(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getBrightnessLevel(const ::Ice::Context& context, const ::Lights::Callback_OutdoorLights_getBrightnessLevelPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getBrightnessLevel(context, cb, cookie);
    }

    ::Ice::Int end_getBrightnessLevel(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getBrightnessLevel(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class GeneralLights : public virtual ::Ice::Proxy<GeneralLights, ::IceProxy::Interfaces::LightControl>
{
public:

    void changeColor(const ::std::string& color, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_changeColor(_iceI_begin_changeColor(color, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_changeColor(const ::std::string& color, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_changeColor(color, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_changeColor(const ::std::string& color, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_changeColor(color, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_changeColor(const ::std::string& color, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_changeColor(color, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_changeColor(const ::std::string& color, const ::Lights::Callback_GeneralLights_changeColorPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_changeColor(color, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_changeColor(const ::std::string& color, const ::Ice::Context& context, const ::Lights::Callback_GeneralLights_changeColorPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_changeColor(color, context, cb, cookie);
    }

    void end_changeColor(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_changeColor(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::std::string getColor(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getColor(_iceI_begin_getColor(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getColor(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getColor(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getColor(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getColor(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getColor(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getColor(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getColor(const ::Lights::Callback_GeneralLights_getColorPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getColor(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getColor(const ::Ice::Context& context, const ::Lights::Callback_GeneralLights_getColorPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getColor(context, cb, cookie);
    }

    ::std::string end_getColor(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getColor(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

namespace Interfaces
{

class SmartDevice : public virtual ::Ice::Object
{
public:

    typedef SmartDevicePrx ProxyType;
    typedef SmartDevicePtr PointerType;

    virtual ~SmartDevice();

#ifdef ICE_CPP11_COMPILER
    SmartDevice() = default;
    SmartDevice(const SmartDevice&) = default;
    SmartDevice& operator=(const SmartDevice&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void changeMode(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_changeMode(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Enums::Mode getMode(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getMode(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void notify(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_notify(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const SmartDevice& lhs, const SmartDevice& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const SmartDevice& lhs, const SmartDevice& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class Detector : virtual public SmartDevice
{
public:

    typedef DetectorPrx ProxyType;
    typedef DetectorPtr PointerType;

    virtual ~Detector();

#ifdef ICE_CPP11_COMPILER
    Detector() = default;
    Detector(const Detector&) = default;
    Detector& operator=(const Detector&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void setSensitivityLevel(::Ice::Int level, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setSensitivityLevel(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::Int getSensitivityLevel(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getSensitivityLevel(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::string getLocation(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getLocation(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void setLocation(const ::std::string& location, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setLocation(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const Detector& lhs, const Detector& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Detector& lhs, const Detector& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class LightControl : virtual public SmartDevice
{
public:

    typedef LightControlPrx ProxyType;
    typedef LightControlPtr PointerType;

    virtual ~LightControl();

#ifdef ICE_CPP11_COMPILER
    LightControl() = default;
    LightControl(const LightControl&) = default;
    LightControl& operator=(const LightControl&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void turnOn(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_turnOn(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void turnOff(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_turnOff(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool isOn(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_isOn(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const LightControl& lhs, const LightControl& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const LightControl& lhs, const LightControl& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

namespace Detectors
{

class MoveDetector : virtual public ::Interfaces::SmartDevice,
                     virtual public ::Interfaces::Detector
{
public:

    typedef MoveDetectorPrx ProxyType;
    typedef MoveDetectorPtr PointerType;

    virtual ~MoveDetector();

#ifdef ICE_CPP11_COMPILER
    MoveDetector() = default;
    MoveDetector(const MoveDetector&) = default;
    MoveDetector& operator=(const MoveDetector&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual bool motionDetected(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_motionDetected(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const MoveDetector& lhs, const MoveDetector& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const MoveDetector& lhs, const MoveDetector& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class SmokeDetector : virtual public ::Interfaces::SmartDevice,
                      virtual public ::Interfaces::Detector
{
public:

    typedef SmokeDetectorPrx ProxyType;
    typedef SmokeDetectorPtr PointerType;

    virtual ~SmokeDetector();

#ifdef ICE_CPP11_COMPILER
    SmokeDetector() = default;
    SmokeDetector(const SmokeDetector&) = default;
    SmokeDetector& operator=(const SmokeDetector&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual ::Ice::Int getSmokeDensity(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getSmokeDensity(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool isSave(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_isSave(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const SmokeDetector& lhs, const SmokeDetector& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const SmokeDetector& lhs, const SmokeDetector& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

namespace Lights
{

class OutdoorLights : virtual public ::Interfaces::LightControl
{
public:

    typedef OutdoorLightsPrx ProxyType;
    typedef OutdoorLightsPtr PointerType;

    virtual ~OutdoorLights();

#ifdef ICE_CPP11_COMPILER
    OutdoorLights() = default;
    OutdoorLights(const OutdoorLights&) = default;
    OutdoorLights& operator=(const OutdoorLights&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void adjustBrightness(::Ice::Int level, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_adjustBrightness(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::Int getBrightnessLevel(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getBrightnessLevel(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const OutdoorLights& lhs, const OutdoorLights& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const OutdoorLights& lhs, const OutdoorLights& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class GeneralLights : virtual public ::Interfaces::LightControl
{
public:

    typedef GeneralLightsPrx ProxyType;
    typedef GeneralLightsPtr PointerType;

    virtual ~GeneralLights();

#ifdef ICE_CPP11_COMPILER
    GeneralLights() = default;
    GeneralLights(const GeneralLights&) = default;
    GeneralLights& operator=(const GeneralLights&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void changeColor(const ::std::string& color, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_changeColor(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::string getColor(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getColor(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const GeneralLights& lhs, const GeneralLights& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const GeneralLights& lhs, const GeneralLights& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::Enums::Mode>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 1;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

}
/// \endcond

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::Errors::ActionNotPermitted>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::Errors::SensitivityLevelOutOfRange>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::Errors::UnknownColor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::Errors::BrightnessLevelOutOfRange>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

}
/// \endcond

/// \cond STREAM
namespace Ice
{

}
/// \endcond

/// \cond STREAM
namespace Ice
{

}
/// \endcond

/// \cond STREAM
namespace Ice
{

}
/// \endcond

namespace Interfaces
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Interfaces::SmartDevice::begin_changeMode.
 * Create a wrapper instance by calling ::Interfaces::newCallback_SmartDevice_changeMode.
 */
template<class T>
class CallbackNC_SmartDevice_changeMode : public Callback_SmartDevice_changeMode_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_SmartDevice_changeMode(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::SmartDevice::begin_changeMode.
 */
template<class T> Callback_SmartDevice_changeModePtr
newCallback_SmartDevice_changeMode(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SmartDevice_changeMode<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::SmartDevice::begin_changeMode.
 */
template<class T> Callback_SmartDevice_changeModePtr
newCallback_SmartDevice_changeMode(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SmartDevice_changeMode<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::SmartDevice::begin_changeMode.
 */
template<class T> Callback_SmartDevice_changeModePtr
newCallback_SmartDevice_changeMode(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SmartDevice_changeMode<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::SmartDevice::begin_changeMode.
 */
template<class T> Callback_SmartDevice_changeModePtr
newCallback_SmartDevice_changeMode(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SmartDevice_changeMode<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Interfaces::SmartDevice::begin_changeMode.
 * Create a wrapper instance by calling ::Interfaces::newCallback_SmartDevice_changeMode.
 */
template<class T, typename CT>
class Callback_SmartDevice_changeMode : public Callback_SmartDevice_changeMode_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_SmartDevice_changeMode(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::SmartDevice::begin_changeMode.
 */
template<class T, typename CT> Callback_SmartDevice_changeModePtr
newCallback_SmartDevice_changeMode(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SmartDevice_changeMode<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::SmartDevice::begin_changeMode.
 */
template<class T, typename CT> Callback_SmartDevice_changeModePtr
newCallback_SmartDevice_changeMode(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SmartDevice_changeMode<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::SmartDevice::begin_changeMode.
 */
template<class T, typename CT> Callback_SmartDevice_changeModePtr
newCallback_SmartDevice_changeMode(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SmartDevice_changeMode<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::SmartDevice::begin_changeMode.
 */
template<class T, typename CT> Callback_SmartDevice_changeModePtr
newCallback_SmartDevice_changeMode(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SmartDevice_changeMode<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Interfaces::SmartDevice::begin_getMode.
 * Create a wrapper instance by calling ::Interfaces::newCallback_SmartDevice_getMode.
 */
template<class T>
class CallbackNC_SmartDevice_getMode : public Callback_SmartDevice_getMode_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Enums::Mode);

    CallbackNC_SmartDevice_getMode(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SmartDevicePrx proxy = SmartDevicePrx::uncheckedCast(result->getProxy());
        ::Enums::Mode ret;
        try
        {
            ret = proxy->end_getMode(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::SmartDevice::begin_getMode.
 */
template<class T> Callback_SmartDevice_getModePtr
newCallback_SmartDevice_getMode(const IceUtil::Handle<T>& instance, void (T::*cb)(::Enums::Mode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SmartDevice_getMode<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::SmartDevice::begin_getMode.
 */
template<class T> Callback_SmartDevice_getModePtr
newCallback_SmartDevice_getMode(T* instance, void (T::*cb)(::Enums::Mode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SmartDevice_getMode<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Interfaces::SmartDevice::begin_getMode.
 * Create a wrapper instance by calling ::Interfaces::newCallback_SmartDevice_getMode.
 */
template<class T, typename CT>
class Callback_SmartDevice_getMode : public Callback_SmartDevice_getMode_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Enums::Mode, const CT&);

    Callback_SmartDevice_getMode(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SmartDevicePrx proxy = SmartDevicePrx::uncheckedCast(result->getProxy());
        ::Enums::Mode ret;
        try
        {
            ret = proxy->end_getMode(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::SmartDevice::begin_getMode.
 */
template<class T, typename CT> Callback_SmartDevice_getModePtr
newCallback_SmartDevice_getMode(const IceUtil::Handle<T>& instance, void (T::*cb)(::Enums::Mode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SmartDevice_getMode<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::SmartDevice::begin_getMode.
 */
template<class T, typename CT> Callback_SmartDevice_getModePtr
newCallback_SmartDevice_getMode(T* instance, void (T::*cb)(::Enums::Mode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SmartDevice_getMode<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Interfaces::SmartDevice::begin_notify.
 * Create a wrapper instance by calling ::Interfaces::newCallback_SmartDevice_notify.
 */
template<class T>
class CallbackNC_SmartDevice_notify : public Callback_SmartDevice_notify_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_SmartDevice_notify(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SmartDevicePrx proxy = SmartDevicePrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_notify(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::SmartDevice::begin_notify.
 */
template<class T> Callback_SmartDevice_notifyPtr
newCallback_SmartDevice_notify(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SmartDevice_notify<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::SmartDevice::begin_notify.
 */
template<class T> Callback_SmartDevice_notifyPtr
newCallback_SmartDevice_notify(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SmartDevice_notify<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::SmartDevice::begin_notify.
 */
template<class T> Callback_SmartDevice_notifyPtr
newCallback_SmartDevice_notify(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SmartDevice_notify<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::SmartDevice::begin_notify.
 */
template<class T> Callback_SmartDevice_notifyPtr
newCallback_SmartDevice_notify(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SmartDevice_notify<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Interfaces::SmartDevice::begin_notify.
 * Create a wrapper instance by calling ::Interfaces::newCallback_SmartDevice_notify.
 */
template<class T, typename CT>
class Callback_SmartDevice_notify : public Callback_SmartDevice_notify_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_SmartDevice_notify(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SmartDevicePrx proxy = SmartDevicePrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_notify(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::SmartDevice::begin_notify.
 */
template<class T, typename CT> Callback_SmartDevice_notifyPtr
newCallback_SmartDevice_notify(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SmartDevice_notify<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::SmartDevice::begin_notify.
 */
template<class T, typename CT> Callback_SmartDevice_notifyPtr
newCallback_SmartDevice_notify(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SmartDevice_notify<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::SmartDevice::begin_notify.
 */
template<class T, typename CT> Callback_SmartDevice_notifyPtr
newCallback_SmartDevice_notify(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SmartDevice_notify<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::SmartDevice::begin_notify.
 */
template<class T, typename CT> Callback_SmartDevice_notifyPtr
newCallback_SmartDevice_notify(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SmartDevice_notify<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Interfaces::Detector::begin_setSensitivityLevel.
 * Create a wrapper instance by calling ::Interfaces::newCallback_Detector_setSensitivityLevel.
 */
template<class T>
class CallbackNC_Detector_setSensitivityLevel : public Callback_Detector_setSensitivityLevel_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Detector_setSensitivityLevel(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        DetectorPrx proxy = DetectorPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_setSensitivityLevel(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::Detector::begin_setSensitivityLevel.
 */
template<class T> Callback_Detector_setSensitivityLevelPtr
newCallback_Detector_setSensitivityLevel(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Detector_setSensitivityLevel<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::Detector::begin_setSensitivityLevel.
 */
template<class T> Callback_Detector_setSensitivityLevelPtr
newCallback_Detector_setSensitivityLevel(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Detector_setSensitivityLevel<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::Detector::begin_setSensitivityLevel.
 */
template<class T> Callback_Detector_setSensitivityLevelPtr
newCallback_Detector_setSensitivityLevel(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Detector_setSensitivityLevel<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::Detector::begin_setSensitivityLevel.
 */
template<class T> Callback_Detector_setSensitivityLevelPtr
newCallback_Detector_setSensitivityLevel(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Detector_setSensitivityLevel<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Interfaces::Detector::begin_setSensitivityLevel.
 * Create a wrapper instance by calling ::Interfaces::newCallback_Detector_setSensitivityLevel.
 */
template<class T, typename CT>
class Callback_Detector_setSensitivityLevel : public Callback_Detector_setSensitivityLevel_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Detector_setSensitivityLevel(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        DetectorPrx proxy = DetectorPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_setSensitivityLevel(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::Detector::begin_setSensitivityLevel.
 */
template<class T, typename CT> Callback_Detector_setSensitivityLevelPtr
newCallback_Detector_setSensitivityLevel(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Detector_setSensitivityLevel<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::Detector::begin_setSensitivityLevel.
 */
template<class T, typename CT> Callback_Detector_setSensitivityLevelPtr
newCallback_Detector_setSensitivityLevel(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Detector_setSensitivityLevel<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::Detector::begin_setSensitivityLevel.
 */
template<class T, typename CT> Callback_Detector_setSensitivityLevelPtr
newCallback_Detector_setSensitivityLevel(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Detector_setSensitivityLevel<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::Detector::begin_setSensitivityLevel.
 */
template<class T, typename CT> Callback_Detector_setSensitivityLevelPtr
newCallback_Detector_setSensitivityLevel(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Detector_setSensitivityLevel<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Interfaces::Detector::begin_getSensitivityLevel.
 * Create a wrapper instance by calling ::Interfaces::newCallback_Detector_getSensitivityLevel.
 */
template<class T>
class CallbackNC_Detector_getSensitivityLevel : public Callback_Detector_getSensitivityLevel_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_Detector_getSensitivityLevel(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        DetectorPrx proxy = DetectorPrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_getSensitivityLevel(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::Detector::begin_getSensitivityLevel.
 */
template<class T> Callback_Detector_getSensitivityLevelPtr
newCallback_Detector_getSensitivityLevel(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Detector_getSensitivityLevel<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::Detector::begin_getSensitivityLevel.
 */
template<class T> Callback_Detector_getSensitivityLevelPtr
newCallback_Detector_getSensitivityLevel(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Detector_getSensitivityLevel<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Interfaces::Detector::begin_getSensitivityLevel.
 * Create a wrapper instance by calling ::Interfaces::newCallback_Detector_getSensitivityLevel.
 */
template<class T, typename CT>
class Callback_Detector_getSensitivityLevel : public Callback_Detector_getSensitivityLevel_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_Detector_getSensitivityLevel(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        DetectorPrx proxy = DetectorPrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_getSensitivityLevel(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::Detector::begin_getSensitivityLevel.
 */
template<class T, typename CT> Callback_Detector_getSensitivityLevelPtr
newCallback_Detector_getSensitivityLevel(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Detector_getSensitivityLevel<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::Detector::begin_getSensitivityLevel.
 */
template<class T, typename CT> Callback_Detector_getSensitivityLevelPtr
newCallback_Detector_getSensitivityLevel(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Detector_getSensitivityLevel<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Interfaces::Detector::begin_getLocation.
 * Create a wrapper instance by calling ::Interfaces::newCallback_Detector_getLocation.
 */
template<class T>
class CallbackNC_Detector_getLocation : public Callback_Detector_getLocation_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_Detector_getLocation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        DetectorPrx proxy = DetectorPrx::uncheckedCast(result->getProxy());
        ::std::string ret;
        try
        {
            ret = proxy->end_getLocation(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::Detector::begin_getLocation.
 */
template<class T> Callback_Detector_getLocationPtr
newCallback_Detector_getLocation(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Detector_getLocation<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::Detector::begin_getLocation.
 */
template<class T> Callback_Detector_getLocationPtr
newCallback_Detector_getLocation(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Detector_getLocation<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Interfaces::Detector::begin_getLocation.
 * Create a wrapper instance by calling ::Interfaces::newCallback_Detector_getLocation.
 */
template<class T, typename CT>
class Callback_Detector_getLocation : public Callback_Detector_getLocation_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_Detector_getLocation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        DetectorPrx proxy = DetectorPrx::uncheckedCast(result->getProxy());
        ::std::string ret;
        try
        {
            ret = proxy->end_getLocation(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::Detector::begin_getLocation.
 */
template<class T, typename CT> Callback_Detector_getLocationPtr
newCallback_Detector_getLocation(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Detector_getLocation<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::Detector::begin_getLocation.
 */
template<class T, typename CT> Callback_Detector_getLocationPtr
newCallback_Detector_getLocation(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Detector_getLocation<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Interfaces::Detector::begin_setLocation.
 * Create a wrapper instance by calling ::Interfaces::newCallback_Detector_setLocation.
 */
template<class T>
class CallbackNC_Detector_setLocation : public Callback_Detector_setLocation_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Detector_setLocation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        DetectorPrx proxy = DetectorPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_setLocation(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::Detector::begin_setLocation.
 */
template<class T> Callback_Detector_setLocationPtr
newCallback_Detector_setLocation(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Detector_setLocation<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::Detector::begin_setLocation.
 */
template<class T> Callback_Detector_setLocationPtr
newCallback_Detector_setLocation(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Detector_setLocation<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::Detector::begin_setLocation.
 */
template<class T> Callback_Detector_setLocationPtr
newCallback_Detector_setLocation(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Detector_setLocation<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::Detector::begin_setLocation.
 */
template<class T> Callback_Detector_setLocationPtr
newCallback_Detector_setLocation(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Detector_setLocation<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Interfaces::Detector::begin_setLocation.
 * Create a wrapper instance by calling ::Interfaces::newCallback_Detector_setLocation.
 */
template<class T, typename CT>
class Callback_Detector_setLocation : public Callback_Detector_setLocation_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Detector_setLocation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        DetectorPrx proxy = DetectorPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_setLocation(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::Detector::begin_setLocation.
 */
template<class T, typename CT> Callback_Detector_setLocationPtr
newCallback_Detector_setLocation(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Detector_setLocation<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::Detector::begin_setLocation.
 */
template<class T, typename CT> Callback_Detector_setLocationPtr
newCallback_Detector_setLocation(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Detector_setLocation<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::Detector::begin_setLocation.
 */
template<class T, typename CT> Callback_Detector_setLocationPtr
newCallback_Detector_setLocation(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Detector_setLocation<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::Detector::begin_setLocation.
 */
template<class T, typename CT> Callback_Detector_setLocationPtr
newCallback_Detector_setLocation(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Detector_setLocation<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Interfaces::LightControl::begin_turnOn.
 * Create a wrapper instance by calling ::Interfaces::newCallback_LightControl_turnOn.
 */
template<class T>
class CallbackNC_LightControl_turnOn : public Callback_LightControl_turnOn_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LightControl_turnOn(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LightControlPrx proxy = LightControlPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_turnOn(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::LightControl::begin_turnOn.
 */
template<class T> Callback_LightControl_turnOnPtr
newCallback_LightControl_turnOn(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LightControl_turnOn<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::LightControl::begin_turnOn.
 */
template<class T> Callback_LightControl_turnOnPtr
newCallback_LightControl_turnOn(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LightControl_turnOn<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::LightControl::begin_turnOn.
 */
template<class T> Callback_LightControl_turnOnPtr
newCallback_LightControl_turnOn(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LightControl_turnOn<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::LightControl::begin_turnOn.
 */
template<class T> Callback_LightControl_turnOnPtr
newCallback_LightControl_turnOn(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LightControl_turnOn<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Interfaces::LightControl::begin_turnOn.
 * Create a wrapper instance by calling ::Interfaces::newCallback_LightControl_turnOn.
 */
template<class T, typename CT>
class Callback_LightControl_turnOn : public Callback_LightControl_turnOn_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LightControl_turnOn(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LightControlPrx proxy = LightControlPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_turnOn(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::LightControl::begin_turnOn.
 */
template<class T, typename CT> Callback_LightControl_turnOnPtr
newCallback_LightControl_turnOn(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LightControl_turnOn<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::LightControl::begin_turnOn.
 */
template<class T, typename CT> Callback_LightControl_turnOnPtr
newCallback_LightControl_turnOn(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LightControl_turnOn<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::LightControl::begin_turnOn.
 */
template<class T, typename CT> Callback_LightControl_turnOnPtr
newCallback_LightControl_turnOn(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LightControl_turnOn<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::LightControl::begin_turnOn.
 */
template<class T, typename CT> Callback_LightControl_turnOnPtr
newCallback_LightControl_turnOn(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LightControl_turnOn<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Interfaces::LightControl::begin_turnOff.
 * Create a wrapper instance by calling ::Interfaces::newCallback_LightControl_turnOff.
 */
template<class T>
class CallbackNC_LightControl_turnOff : public Callback_LightControl_turnOff_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LightControl_turnOff(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LightControlPrx proxy = LightControlPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_turnOff(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::LightControl::begin_turnOff.
 */
template<class T> Callback_LightControl_turnOffPtr
newCallback_LightControl_turnOff(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LightControl_turnOff<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::LightControl::begin_turnOff.
 */
template<class T> Callback_LightControl_turnOffPtr
newCallback_LightControl_turnOff(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LightControl_turnOff<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::LightControl::begin_turnOff.
 */
template<class T> Callback_LightControl_turnOffPtr
newCallback_LightControl_turnOff(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LightControl_turnOff<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::LightControl::begin_turnOff.
 */
template<class T> Callback_LightControl_turnOffPtr
newCallback_LightControl_turnOff(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LightControl_turnOff<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Interfaces::LightControl::begin_turnOff.
 * Create a wrapper instance by calling ::Interfaces::newCallback_LightControl_turnOff.
 */
template<class T, typename CT>
class Callback_LightControl_turnOff : public Callback_LightControl_turnOff_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LightControl_turnOff(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LightControlPrx proxy = LightControlPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_turnOff(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::LightControl::begin_turnOff.
 */
template<class T, typename CT> Callback_LightControl_turnOffPtr
newCallback_LightControl_turnOff(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LightControl_turnOff<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::LightControl::begin_turnOff.
 */
template<class T, typename CT> Callback_LightControl_turnOffPtr
newCallback_LightControl_turnOff(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LightControl_turnOff<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::LightControl::begin_turnOff.
 */
template<class T, typename CT> Callback_LightControl_turnOffPtr
newCallback_LightControl_turnOff(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LightControl_turnOff<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::LightControl::begin_turnOff.
 */
template<class T, typename CT> Callback_LightControl_turnOffPtr
newCallback_LightControl_turnOff(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LightControl_turnOff<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Interfaces::LightControl::begin_isOn.
 * Create a wrapper instance by calling ::Interfaces::newCallback_LightControl_isOn.
 */
template<class T>
class CallbackNC_LightControl_isOn : public Callback_LightControl_isOn_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_LightControl_isOn(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LightControlPrx proxy = LightControlPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_isOn(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::LightControl::begin_isOn.
 */
template<class T> Callback_LightControl_isOnPtr
newCallback_LightControl_isOn(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LightControl_isOn<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::LightControl::begin_isOn.
 */
template<class T> Callback_LightControl_isOnPtr
newCallback_LightControl_isOn(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LightControl_isOn<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Interfaces::LightControl::begin_isOn.
 * Create a wrapper instance by calling ::Interfaces::newCallback_LightControl_isOn.
 */
template<class T, typename CT>
class Callback_LightControl_isOn : public Callback_LightControl_isOn_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_LightControl_isOn(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LightControlPrx proxy = LightControlPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_isOn(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::LightControl::begin_isOn.
 */
template<class T, typename CT> Callback_LightControl_isOnPtr
newCallback_LightControl_isOn(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LightControl_isOn<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Interfaces::LightControl::begin_isOn.
 */
template<class T, typename CT> Callback_LightControl_isOnPtr
newCallback_LightControl_isOn(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LightControl_isOn<T, CT>(instance, cb, excb, sentcb);
}

}

namespace Detectors
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Detectors::MoveDetector::begin_motionDetected.
 * Create a wrapper instance by calling ::Detectors::newCallback_MoveDetector_motionDetected.
 */
template<class T>
class CallbackNC_MoveDetector_motionDetected : public Callback_MoveDetector_motionDetected_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_MoveDetector_motionDetected(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MoveDetectorPrx proxy = MoveDetectorPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_motionDetected(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Detectors::MoveDetector::begin_motionDetected.
 */
template<class T> Callback_MoveDetector_motionDetectedPtr
newCallback_MoveDetector_motionDetected(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MoveDetector_motionDetected<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Detectors::MoveDetector::begin_motionDetected.
 */
template<class T> Callback_MoveDetector_motionDetectedPtr
newCallback_MoveDetector_motionDetected(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MoveDetector_motionDetected<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Detectors::MoveDetector::begin_motionDetected.
 * Create a wrapper instance by calling ::Detectors::newCallback_MoveDetector_motionDetected.
 */
template<class T, typename CT>
class Callback_MoveDetector_motionDetected : public Callback_MoveDetector_motionDetected_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_MoveDetector_motionDetected(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MoveDetectorPrx proxy = MoveDetectorPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_motionDetected(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Detectors::MoveDetector::begin_motionDetected.
 */
template<class T, typename CT> Callback_MoveDetector_motionDetectedPtr
newCallback_MoveDetector_motionDetected(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MoveDetector_motionDetected<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Detectors::MoveDetector::begin_motionDetected.
 */
template<class T, typename CT> Callback_MoveDetector_motionDetectedPtr
newCallback_MoveDetector_motionDetected(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MoveDetector_motionDetected<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Detectors::SmokeDetector::begin_getSmokeDensity.
 * Create a wrapper instance by calling ::Detectors::newCallback_SmokeDetector_getSmokeDensity.
 */
template<class T>
class CallbackNC_SmokeDetector_getSmokeDensity : public Callback_SmokeDetector_getSmokeDensity_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_SmokeDetector_getSmokeDensity(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SmokeDetectorPrx proxy = SmokeDetectorPrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_getSmokeDensity(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Detectors::SmokeDetector::begin_getSmokeDensity.
 */
template<class T> Callback_SmokeDetector_getSmokeDensityPtr
newCallback_SmokeDetector_getSmokeDensity(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SmokeDetector_getSmokeDensity<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Detectors::SmokeDetector::begin_getSmokeDensity.
 */
template<class T> Callback_SmokeDetector_getSmokeDensityPtr
newCallback_SmokeDetector_getSmokeDensity(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SmokeDetector_getSmokeDensity<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Detectors::SmokeDetector::begin_getSmokeDensity.
 * Create a wrapper instance by calling ::Detectors::newCallback_SmokeDetector_getSmokeDensity.
 */
template<class T, typename CT>
class Callback_SmokeDetector_getSmokeDensity : public Callback_SmokeDetector_getSmokeDensity_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_SmokeDetector_getSmokeDensity(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SmokeDetectorPrx proxy = SmokeDetectorPrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_getSmokeDensity(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Detectors::SmokeDetector::begin_getSmokeDensity.
 */
template<class T, typename CT> Callback_SmokeDetector_getSmokeDensityPtr
newCallback_SmokeDetector_getSmokeDensity(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SmokeDetector_getSmokeDensity<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Detectors::SmokeDetector::begin_getSmokeDensity.
 */
template<class T, typename CT> Callback_SmokeDetector_getSmokeDensityPtr
newCallback_SmokeDetector_getSmokeDensity(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SmokeDetector_getSmokeDensity<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Detectors::SmokeDetector::begin_isSave.
 * Create a wrapper instance by calling ::Detectors::newCallback_SmokeDetector_isSave.
 */
template<class T>
class CallbackNC_SmokeDetector_isSave : public Callback_SmokeDetector_isSave_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_SmokeDetector_isSave(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SmokeDetectorPrx proxy = SmokeDetectorPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_isSave(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Detectors::SmokeDetector::begin_isSave.
 */
template<class T> Callback_SmokeDetector_isSavePtr
newCallback_SmokeDetector_isSave(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SmokeDetector_isSave<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Detectors::SmokeDetector::begin_isSave.
 */
template<class T> Callback_SmokeDetector_isSavePtr
newCallback_SmokeDetector_isSave(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SmokeDetector_isSave<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Detectors::SmokeDetector::begin_isSave.
 * Create a wrapper instance by calling ::Detectors::newCallback_SmokeDetector_isSave.
 */
template<class T, typename CT>
class Callback_SmokeDetector_isSave : public Callback_SmokeDetector_isSave_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_SmokeDetector_isSave(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SmokeDetectorPrx proxy = SmokeDetectorPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_isSave(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Detectors::SmokeDetector::begin_isSave.
 */
template<class T, typename CT> Callback_SmokeDetector_isSavePtr
newCallback_SmokeDetector_isSave(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SmokeDetector_isSave<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Detectors::SmokeDetector::begin_isSave.
 */
template<class T, typename CT> Callback_SmokeDetector_isSavePtr
newCallback_SmokeDetector_isSave(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SmokeDetector_isSave<T, CT>(instance, cb, excb, sentcb);
}

}

namespace Lights
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Lights::OutdoorLights::begin_adjustBrightness.
 * Create a wrapper instance by calling ::Lights::newCallback_OutdoorLights_adjustBrightness.
 */
template<class T>
class CallbackNC_OutdoorLights_adjustBrightness : public Callback_OutdoorLights_adjustBrightness_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_OutdoorLights_adjustBrightness(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        OutdoorLightsPrx proxy = OutdoorLightsPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_adjustBrightness(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Lights::OutdoorLights::begin_adjustBrightness.
 */
template<class T> Callback_OutdoorLights_adjustBrightnessPtr
newCallback_OutdoorLights_adjustBrightness(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OutdoorLights_adjustBrightness<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Lights::OutdoorLights::begin_adjustBrightness.
 */
template<class T> Callback_OutdoorLights_adjustBrightnessPtr
newCallback_OutdoorLights_adjustBrightness(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OutdoorLights_adjustBrightness<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Lights::OutdoorLights::begin_adjustBrightness.
 */
template<class T> Callback_OutdoorLights_adjustBrightnessPtr
newCallback_OutdoorLights_adjustBrightness(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OutdoorLights_adjustBrightness<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Lights::OutdoorLights::begin_adjustBrightness.
 */
template<class T> Callback_OutdoorLights_adjustBrightnessPtr
newCallback_OutdoorLights_adjustBrightness(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OutdoorLights_adjustBrightness<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Lights::OutdoorLights::begin_adjustBrightness.
 * Create a wrapper instance by calling ::Lights::newCallback_OutdoorLights_adjustBrightness.
 */
template<class T, typename CT>
class Callback_OutdoorLights_adjustBrightness : public Callback_OutdoorLights_adjustBrightness_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_OutdoorLights_adjustBrightness(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        OutdoorLightsPrx proxy = OutdoorLightsPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_adjustBrightness(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Lights::OutdoorLights::begin_adjustBrightness.
 */
template<class T, typename CT> Callback_OutdoorLights_adjustBrightnessPtr
newCallback_OutdoorLights_adjustBrightness(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OutdoorLights_adjustBrightness<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Lights::OutdoorLights::begin_adjustBrightness.
 */
template<class T, typename CT> Callback_OutdoorLights_adjustBrightnessPtr
newCallback_OutdoorLights_adjustBrightness(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OutdoorLights_adjustBrightness<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Lights::OutdoorLights::begin_adjustBrightness.
 */
template<class T, typename CT> Callback_OutdoorLights_adjustBrightnessPtr
newCallback_OutdoorLights_adjustBrightness(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OutdoorLights_adjustBrightness<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Lights::OutdoorLights::begin_adjustBrightness.
 */
template<class T, typename CT> Callback_OutdoorLights_adjustBrightnessPtr
newCallback_OutdoorLights_adjustBrightness(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OutdoorLights_adjustBrightness<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Lights::OutdoorLights::begin_getBrightnessLevel.
 * Create a wrapper instance by calling ::Lights::newCallback_OutdoorLights_getBrightnessLevel.
 */
template<class T>
class CallbackNC_OutdoorLights_getBrightnessLevel : public Callback_OutdoorLights_getBrightnessLevel_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_OutdoorLights_getBrightnessLevel(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        OutdoorLightsPrx proxy = OutdoorLightsPrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_getBrightnessLevel(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Lights::OutdoorLights::begin_getBrightnessLevel.
 */
template<class T> Callback_OutdoorLights_getBrightnessLevelPtr
newCallback_OutdoorLights_getBrightnessLevel(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OutdoorLights_getBrightnessLevel<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Lights::OutdoorLights::begin_getBrightnessLevel.
 */
template<class T> Callback_OutdoorLights_getBrightnessLevelPtr
newCallback_OutdoorLights_getBrightnessLevel(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OutdoorLights_getBrightnessLevel<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Lights::OutdoorLights::begin_getBrightnessLevel.
 * Create a wrapper instance by calling ::Lights::newCallback_OutdoorLights_getBrightnessLevel.
 */
template<class T, typename CT>
class Callback_OutdoorLights_getBrightnessLevel : public Callback_OutdoorLights_getBrightnessLevel_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_OutdoorLights_getBrightnessLevel(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        OutdoorLightsPrx proxy = OutdoorLightsPrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_getBrightnessLevel(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Lights::OutdoorLights::begin_getBrightnessLevel.
 */
template<class T, typename CT> Callback_OutdoorLights_getBrightnessLevelPtr
newCallback_OutdoorLights_getBrightnessLevel(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OutdoorLights_getBrightnessLevel<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Lights::OutdoorLights::begin_getBrightnessLevel.
 */
template<class T, typename CT> Callback_OutdoorLights_getBrightnessLevelPtr
newCallback_OutdoorLights_getBrightnessLevel(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OutdoorLights_getBrightnessLevel<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Lights::GeneralLights::begin_changeColor.
 * Create a wrapper instance by calling ::Lights::newCallback_GeneralLights_changeColor.
 */
template<class T>
class CallbackNC_GeneralLights_changeColor : public Callback_GeneralLights_changeColor_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_GeneralLights_changeColor(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GeneralLightsPrx proxy = GeneralLightsPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_changeColor(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Lights::GeneralLights::begin_changeColor.
 */
template<class T> Callback_GeneralLights_changeColorPtr
newCallback_GeneralLights_changeColor(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GeneralLights_changeColor<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Lights::GeneralLights::begin_changeColor.
 */
template<class T> Callback_GeneralLights_changeColorPtr
newCallback_GeneralLights_changeColor(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GeneralLights_changeColor<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Lights::GeneralLights::begin_changeColor.
 */
template<class T> Callback_GeneralLights_changeColorPtr
newCallback_GeneralLights_changeColor(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GeneralLights_changeColor<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Lights::GeneralLights::begin_changeColor.
 */
template<class T> Callback_GeneralLights_changeColorPtr
newCallback_GeneralLights_changeColor(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GeneralLights_changeColor<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Lights::GeneralLights::begin_changeColor.
 * Create a wrapper instance by calling ::Lights::newCallback_GeneralLights_changeColor.
 */
template<class T, typename CT>
class Callback_GeneralLights_changeColor : public Callback_GeneralLights_changeColor_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_GeneralLights_changeColor(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GeneralLightsPrx proxy = GeneralLightsPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_changeColor(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Lights::GeneralLights::begin_changeColor.
 */
template<class T, typename CT> Callback_GeneralLights_changeColorPtr
newCallback_GeneralLights_changeColor(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GeneralLights_changeColor<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Lights::GeneralLights::begin_changeColor.
 */
template<class T, typename CT> Callback_GeneralLights_changeColorPtr
newCallback_GeneralLights_changeColor(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GeneralLights_changeColor<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Lights::GeneralLights::begin_changeColor.
 */
template<class T, typename CT> Callback_GeneralLights_changeColorPtr
newCallback_GeneralLights_changeColor(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GeneralLights_changeColor<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Lights::GeneralLights::begin_changeColor.
 */
template<class T, typename CT> Callback_GeneralLights_changeColorPtr
newCallback_GeneralLights_changeColor(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GeneralLights_changeColor<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Lights::GeneralLights::begin_getColor.
 * Create a wrapper instance by calling ::Lights::newCallback_GeneralLights_getColor.
 */
template<class T>
class CallbackNC_GeneralLights_getColor : public Callback_GeneralLights_getColor_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_GeneralLights_getColor(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GeneralLightsPrx proxy = GeneralLightsPrx::uncheckedCast(result->getProxy());
        ::std::string ret;
        try
        {
            ret = proxy->end_getColor(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Lights::GeneralLights::begin_getColor.
 */
template<class T> Callback_GeneralLights_getColorPtr
newCallback_GeneralLights_getColor(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GeneralLights_getColor<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Lights::GeneralLights::begin_getColor.
 */
template<class T> Callback_GeneralLights_getColorPtr
newCallback_GeneralLights_getColor(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GeneralLights_getColor<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Lights::GeneralLights::begin_getColor.
 * Create a wrapper instance by calling ::Lights::newCallback_GeneralLights_getColor.
 */
template<class T, typename CT>
class Callback_GeneralLights_getColor : public Callback_GeneralLights_getColor_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_GeneralLights_getColor(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GeneralLightsPrx proxy = GeneralLightsPrx::uncheckedCast(result->getProxy());
        ::std::string ret;
        try
        {
            ret = proxy->end_getColor(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Lights::GeneralLights::begin_getColor.
 */
template<class T, typename CT> Callback_GeneralLights_getColorPtr
newCallback_GeneralLights_getColor(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GeneralLights_getColor<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Lights::GeneralLights::begin_getColor.
 */
template<class T, typename CT> Callback_GeneralLights_getColorPtr
newCallback_GeneralLights_getColor(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GeneralLights_getColor<T, CT>(instance, cb, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
